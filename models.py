# generated by datamodel-codegen:
#   filename:  local-retail.yaml
#   timestamp: 2024-08-07T12:35:20+00:00

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Any, List, Optional

from pydantic import AnyUrl, BaseModel, EmailStr, Field, confloat, conint, constr


class Action(Enum):
    search = 'search'


class Action1(Enum):
    select = 'select'


class Status(Enum):
    ACK = 'ACK'
    NACK = 'NACK'


class Ack(BaseModel):
    status: Status = Field(
        ...,
        description='Describe the status of the ACK response. If schema validation passes, status is ACK else it is NACK',
    )


class Address(BaseModel):
    door: Optional[str] = Field(None, description='Door / Shop number of the address')
    name: Optional[str] = Field(
        None, description='Name of address if applicable. Example, shop name'
    )
    building: Optional[str] = Field(None, description='Name of the building or block')
    street: Optional[str] = Field(None, description='Street name or number')
    locality: Optional[str] = Field(
        None, description='Name of the locality, apartments'
    )
    ward: Optional[str] = Field(
        None, description='Name or number of the ward if applicable'
    )
    city: Optional[str] = Field(None, description='City name')
    state: Optional[str] = Field(None, description='State name')
    country: Optional[str] = Field(None, description='Country name')
    area_code: Optional[str] = Field(
        None, description='Area code. This can be Pincode, ZIP code or any equivalent'
    )


class Authorization(BaseModel):
    type: Optional[str] = Field(
        None, description='Type of authorization mechanism used'
    )
    token: Optional[str] = Field(None, description='Token used for authorization')
    valid_from: Optional[datetime] = Field(
        None, description='Timestamp in RFC3339 format from which token is valid'
    )
    valid_to: Optional[datetime] = Field(
        None, description='Timestamp in RFC3339 format until which token is valid'
    )
    status: Optional[str] = Field(None, description='Status of the token')


class Type(Enum):
    full = 'full'
    partial = 'partial'


class City(BaseModel):
    name: Optional[str] = Field(None, description='Name of the city')
    code: Optional[str] = Field(None, description='City code')


class Action2(Enum):
    search = 'search'
    select = 'select'
    init = 'init'
    confirm = 'confirm'
    update = 'update'
    status = 'status'
    track = 'track'
    cancel = 'cancel'
    rating = 'rating'
    support = 'support'
    on_search = 'on_search'
    on_select = 'on_select'
    on_init = 'on_init'
    on_confirm = 'on_confirm'
    on_update = 'on_update'
    on_status = 'on_status'
    on_track = 'on_track'
    on_cancel = 'on_cancel'
    on_rating = 'on_rating'
    on_support = 'on_support'


class Country(BaseModel):
    name: Optional[str] = Field(None, description='Name of the country')
    code: Optional[str] = Field(
        None, description='Country code as per ISO 3166-1 and ISO 3166-2 format'
    )


class DecimalValue(BaseModel):
    __root__: constr(regex=r'[+-]?([0-9]*[.])?[0-9]+') = Field(
        ..., description='Describes a decimal value'
    )


class Document(BaseModel):
    url: Optional[AnyUrl] = None
    label: Optional[str] = None


class Domain(BaseModel):
    __root__: str = Field(..., description='Describes the domain of an object')


class Duration(BaseModel):
    __root__: str = Field(..., description='Describes duration as per ISO8601 format')


class Type1(Enum):
    CONTEXT_ERROR = 'CONTEXT-ERROR'
    CORE_ERROR = 'CORE-ERROR'
    DOMAIN_ERROR = 'DOMAIN-ERROR'
    POLICY_ERROR = 'POLICY-ERROR'
    JSON_SCHEMA_ERROR = 'JSON-SCHEMA-ERROR'


class Error(BaseModel):
    type: Type1
    code: str = Field(
        ...,
        description='Beckn specific error code. For full list of error codes, refer to error_codes.md in the root folder of this repo',
    )
    path: Optional[str] = Field(
        None,
        description='Path to json schema generating the error. Used only during json schema validation errors',
    )
    message: Optional[str] = Field(
        None, description='Human readable message describing the error'
    )


class AnswerType(Enum):
    radio = 'radio'
    checkbox = 'checkbox'
    text = 'text'


class TlMethod(Enum):
    http_get = 'http/get'
    http_post = 'http/post'


class Params(BaseModel):
    feedback_id: str = Field(
        ...,
        description='This value will be placed in the the $feedback_id url param in case of http/get and in the requestBody http/post requests',
    )


class FeedbackUrl(BaseModel):
    url: Optional[AnyUrl] = Field(None, description='feedback URL sent by the BPP')
    tl_method: Optional[TlMethod] = None
    params: Optional[Params] = None


class Gps(BaseModel):
    __root__: constr(
        regex=r'^[-+]?([1-8]?\d(\.\d+)?|90(\.0+)?),\s*[-+]?(180(\.0+)?|((1[0-7]\d)|([1-9]?\d))(\.\d+)?)$'
    ) = Field(..., description='Describes a gps coordinate')


class Image(BaseModel):
    __root__: str = Field(
        ...,
        description='Image of an object. <br/><br/> A url based image will look like <br/><br/>```uri:http://path/to/image``` <br/><br/> An image can also be sent as a data string. For example : <br/><br/> ```data:js87y34ilhriuho84r3i4```',
    )


class Language(BaseModel):
    code: Optional[str] = None


class Name(BaseModel):
    __root__: constr(regex=r'^\./[^/]+/[^/]*/[^/]*/[^/]*/[^/]*/[^/]*$') = Field(
        ...,
        description='Describes the name of a person in format: ./{given_name}/{honorific_prefix}/{first_name}/{middle_name}/{last_name}/{honorific_suffix}',
    )


class Experience(BaseModel):
    label: Optional[str] = None
    value: Optional[str] = None
    unit: Optional[str] = None


class Organization(BaseModel):
    name: Optional[str] = None
    cred: Optional[str] = None


class Page(BaseModel):
    id: Optional[str] = None
    next_id: Optional[str] = None


class Type2(Enum):
    ON_ORDER = 'ON-ORDER'
    PRE_FULFILLMENT = 'PRE-FULFILLMENT'
    ON_FULFILLMENT = 'ON-FULFILLMENT'
    POST_FULFILLMENT = 'POST-FULFILLMENT'


class Status1(Enum):
    PAID = 'PAID'
    NOT_PAID = 'NOT-PAID'


class Price(BaseModel):
    currency: Optional[str] = None
    value: Optional[DecimalValue] = None
    estimated_value: Optional[DecimalValue] = None
    computed_value: Optional[DecimalValue] = None
    listed_value: Optional[DecimalValue] = None
    offered_value: Optional[DecimalValue] = None
    minimum_value: Optional[DecimalValue] = None
    maximum_value: Optional[DecimalValue] = None


class BreakupItem(BaseModel):
    title: Optional[str] = None
    price: Optional[Price] = None


class Quotation(BaseModel):
    price: Optional[Price] = None
    breakup: Optional[List[BreakupItem]] = None
    ttl: Optional[Duration] = None


class Rateable(BaseModel):
    __root__: bool = Field(..., description='If the entity can be rated or not')


class RatingAck(BaseModel):
    feedback_ack: Optional[bool] = Field(
        None, description='If feedback has been recorded or not'
    )
    rating_ack: Optional[bool] = Field(
        None, description='If rating has been recorded or not'
    )


class Type3(Enum):
    CONSTANT = 'CONSTANT'
    VARIABLE = 'VARIABLE'


class Range(BaseModel):
    min: Optional[float] = None
    max: Optional[float] = None


class Scalar(BaseModel):
    type: Optional[Type3] = None
    value: float
    estimated_value: Optional[float] = None
    computed_value: Optional[float] = None
    range: Optional[Range] = None
    unit: str


class Schedule(BaseModel):
    frequency: Optional[Duration] = None
    holidays: Optional[List[datetime]] = None
    times: Optional[List[datetime]] = None


class Type4(Enum):
    bap = 'bap'
    bpp = 'bpp'
    bg = 'bg'
    bppr = 'bppr'
    bgr = 'bgr'


class Status2(Enum):
    INITIATED = 'INITIATED'
    UNDER_SUBSCRIPTION = 'UNDER_SUBSCRIPTION'
    SUBSCRIBED = 'SUBSCRIBED'
    INVALID_SSL = 'INVALID_SSL'
    UNSUBSCRIBED = 'UNSUBSCRIBED'


class Type5(Enum):
    order = 'order'
    billing = 'billing'
    fulfillment = 'fulfillment'


class Tags(BaseModel):
    __root__: Any = Field(
        ...,
        description='Describes a tag. This is a simple key-value store which is used to contain extended metadata',
    )


class Range1(BaseModel):
    start: Optional[datetime] = None
    end: Optional[datetime] = None


class Time(BaseModel):
    label: Optional[str] = None
    timestamp: Optional[datetime] = None
    duration: Optional[Duration] = None
    range: Optional[Range1] = None
    days: Optional[str] = Field(
        None, description='comma separated values representing days of the week'
    )
    schedule: Optional[Schedule] = None


class Status3(Enum):
    active = 'active'
    inactive = 'inactive'


class Tracking(BaseModel):
    url: Optional[AnyUrl] = None
    status: Optional[Status3] = None


class Vehicle(BaseModel):
    category: Optional[str] = None
    capacity: Optional[int] = None
    make: Optional[str] = None
    model: Optional[str] = None
    size: Optional[str] = None
    variant: Optional[str] = None
    color: Optional[str] = None
    energy_type: Optional[str] = None
    registration: Optional[str] = None


class Id(BaseModel):
    __root__: str = Field(
        ...,
        description='ID of the add-on. This follows the syntax {item.id}/add-on/{add-on unique id} for item specific add-on OR ',
    )


class IdModel(BaseModel):
    __root__: str = Field(..., description='Unique id of the category')


class Code(BaseModel):
    __root__: str = Field(..., description='City code')


class CodeModel(BaseModel):
    __root__: str = Field(
        ..., description='Country code as per ISO 3166-1 and ISO 3166-2 format'
    )


class IdModel1(BaseModel):
    __root__: str


class FeedbackId(BaseModel):
    __root__: str = Field(
        ...,
        description='This value will be placed in the the $feedback_id url param in case of http/get and in the requestBody http/post requests',
    )


class IdModel2(BaseModel):
    __root__: str = Field(
        ..., description='Unique reference ID to the fulfillment of an order'
    )


class IdModel3(BaseModel):
    __root__: str = Field(
        ...,
        description='This is the most unique identifier of a service item. An example of an Item ID could be the SKU of a product.',
    )


class Selected(BaseModel):
    count: Optional[conint(ge=0)] = None
    measure: Optional[Scalar] = None


class IdModel4(BaseModel):
    __root__: str


class Currency(BaseModel):
    __root__: str


class Value(BaseModel):
    __root__: DecimalValue


class IdModel5(BaseModel):
    __root__: str = Field(..., description='Id of the provider')


class ValueModel(BaseModel):
    __root__: confloat(ge=0.0) = Field(
        ..., description='Rating value given to the object'
    )


class RetailContext(BaseModel):
    __root__: Any


class RetailSearchContext(BaseModel):
    action: Action


class RetailSelectContext(BaseModel):
    action: Optional[Action1] = None


class Billing(BaseModel):
    name: str = Field(
        ..., description='Personal details of the customer needed for billing.'
    )
    organization: Optional[Organization] = None
    address: Optional[Address] = None
    email: Optional[EmailStr] = None
    phone: str
    time: Optional[Time] = None
    tax_number: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


class SelectedReason(BaseModel):
    id: Optional[IdModel4] = None


class Circle(BaseModel):
    gps: Gps
    radius: Scalar


class Contact(BaseModel):
    phone: Optional[str] = None
    email: Optional[str] = None
    tags: Optional[Tags] = None


class Context(BaseModel):
    domain: Domain
    country: CodeModel
    city: Code
    action: Action2 = Field(
        ...,
        description='Defines the Beckn API call. Any actions other than the enumerated actions are not supported by Beckn Protocol',
    )
    core_version: str = Field(
        ..., description='Version of Beckn core API specification being used'
    )
    bap_id: AnyUrl = Field(
        ...,
        description='Unique id of the BAP. By default it is the fully qualified domain name of the BAP',
    )
    bap_uri: AnyUrl = Field(
        ...,
        description='URI of the BAP for accepting callbacks. Must have the same domain name as the bap_id',
    )
    bpp_id: Optional[AnyUrl] = Field(
        None,
        description='Unique id of the BPP. By default it is the fully qualified domain name of the BPP',
    )
    bpp_uri: Optional[AnyUrl] = Field(
        None, description='URI of the BPP. Must have the same domain name as the bap_id'
    )
    transaction_id: str = Field(
        ...,
        description='This is a unique value which persists across all API calls from search through confirm',
    )
    message_id: str = Field(
        ...,
        description='This is a unique value which persists during a request / callback cycle',
    )
    timestamp: datetime = Field(
        ..., description='Time of request generation in RFC3339 format'
    )
    key: Optional[str] = Field(
        None, description='The encryption public key of the sender'
    )
    ttl: Optional[str] = Field(
        None,
        description='The duration in ISO8601 format after timestamp for which this message holds valid',
    )


class Descriptor(BaseModel):
    name: Optional[str] = None
    code: Optional[str] = None
    symbol: Optional[str] = None
    short_desc: Optional[str] = None
    long_desc: Optional[str] = None
    images: Optional[List[Image]] = None
    audio: Optional[AnyUrl] = None
    field_3d_render: Optional[AnyUrl] = Field(None, alias='3d_render')


class Dimensions(BaseModel):
    length: Optional[Scalar] = None
    breadth: Optional[Scalar] = None
    height: Optional[Scalar] = None


class FeedbackFormElement(BaseModel):
    id: Optional[str] = None
    parent_id: Optional[IdModel1] = None
    question: Optional[str] = Field(
        None,
        description='Specifies the question to which the answer options will be contained in the child FeedbackFormElements',
    )
    answer: Optional[str] = Field(
        None,
        description='Specifies an answer option to which the question will be in the FeedbackFormElement specified in parent_id',
    )
    answer_type: Optional[AnswerType] = Field(
        None, description='Specifies how the answer option should be rendered.'
    )


class Allocated(BaseModel):
    count: Optional[conint(ge=0)] = None
    measure: Optional[Scalar] = None


class Available(BaseModel):
    count: Optional[conint(ge=0)] = None
    measure: Optional[Scalar] = None


class Maximum(BaseModel):
    count: Optional[conint(ge=1)] = None
    measure: Optional[Scalar] = None


class Minimum(BaseModel):
    count: Optional[conint(ge=0)] = None
    measure: Optional[Scalar] = None


class ItemQuantity(BaseModel):
    allocated: Optional[Allocated] = None
    available: Optional[Available] = None
    maximum: Optional[Maximum] = None
    minimum: Optional[Minimum] = None
    selected: Optional[Selected] = None


class Item(BaseModel):
    id: Optional[str] = Field(
        None,
        description='This is the most unique identifier of a service item. An example of an Item ID could be the SKU of a product.',
    )
    parent_item_id: Optional[IdModel3] = None
    descriptor: Optional[Descriptor] = None
    price: Optional[Price] = None
    category_id: Optional[IdModel] = None
    fulfillment_id: Optional[IdModel2] = None
    rating: Optional[ValueModel] = None
    location_id: Optional[IdModel4] = None
    time: Optional[Time] = None
    rateable: Optional[Rateable] = None
    matched: Optional[bool] = None
    related: Optional[bool] = None
    recommended: Optional[bool] = None
    tags: Optional[Tags] = None


class Location(BaseModel):
    id: Optional[str] = None
    descriptor: Optional[Descriptor] = None
    gps: Optional[Gps] = None
    address: Optional[Address] = None
    station_code: Optional[str] = None
    city: Optional[City] = None
    country: Optional[Country] = None
    circle: Optional[Circle] = None
    polygon: Optional[str] = None
    field_3dspace: Optional[str] = Field(None, alias='3dspace')
    time: Optional[Time] = None


class Offer(BaseModel):
    id: Optional[str] = None
    descriptor: Optional[Descriptor] = None
    location_ids: Optional[List[IdModel4]] = None
    category_ids: Optional[List[IdModel]] = None
    item_ids: Optional[List[IdModel3]] = None
    time: Optional[Time] = None


class Option(BaseModel):
    id: Optional[str] = None
    descriptor: Optional[Descriptor] = None


class Location1(BaseModel):
    id: IdModel4


class Provider1(BaseModel):
    id: Optional[IdModel5] = None
    locations: Optional[List[Location1]] = Field(None, max_items=1)


class Item1(BaseModel):
    id: IdModel3
    quantity: Optional[Selected] = None


class AddOn1(BaseModel):
    id: Id


class Offer1(BaseModel):
    id: IdModel4


class Params1(BaseModel):
    transaction_id: Optional[str] = Field(
        None,
        description='This value will be placed in the the $transaction_id url param in case of http/get and in the requestBody http/post requests',
    )
    transaction_status: Optional[str] = None
    amount: Optional[Value] = None
    currency: Currency


class Payment(BaseModel):
    uri: Optional[AnyUrl] = Field(
        None,
        description='A payment uri to be called by the BAP. If empty, then the payment is to be done offline. The details of payment should be present in the params object. If ```tl_method``` = http/get, then the payment details will be sent as url params. Two url param values, ```$transaction_id``` and ```$amount``` are mandatory. And example url would be : https://www.example.com/pay?txid=$transaction_id&amount=$amount&vpa=upiid&payee=shopez&billno=1234',
    )
    tl_method: Optional[TlMethod] = None
    params: Optional[Params1] = None
    type: Optional[Type2] = None
    status: Optional[Status1] = None
    time: Optional[Time] = None


class Person(BaseModel):
    name: Optional[Name] = None
    image: Optional[Image] = None
    dob: Optional[date] = None
    gender: Optional[str] = Field(
        None,
        description='Gender of something, typically a Person, but possibly also fictional characters, animals, etc. While Male and Female may be used, text strings are also acceptable for people who do not identify as a binary gender',
    )
    cred: Optional[str] = None
    tags: Optional[Tags] = None


class Policy(BaseModel):
    id: Optional[str] = None
    descriptor: Optional[Descriptor] = None
    parent_policy_id: Optional[IdModel4] = None
    time: Optional[Time] = None


class Location2(Location):
    rateable: Optional[Rateable] = None


class State(BaseModel):
    descriptor: Optional[Descriptor] = None
    updated_at: Optional[datetime] = None
    updated_by: Optional[str] = Field(
        None, description='ID of entity which changed the state'
    )


class Subscriber(BaseModel):
    subscriber_id: Optional[str] = Field(
        None,
        description='Registered domain name of the subscriber. Must have a valid SSL certificate issued by a Certificate Authority of the operating region',
    )
    type: Optional[Type4] = None
    cb_url: Optional[str] = Field(
        None,
        description="Callback URL of the subscriber. The Registry will call this URL's on_subscribe API to validate the subscriber\\'s credentials",
    )
    domain: Optional[Domain] = None
    city: Optional[Code] = None
    country: Optional[CodeModel] = None
    signing_public_key: Optional[str] = Field(
        None,
        description="Signing Public key of the subscriber. <br/><br/>Any subscriber platform (BAP, BPP, BG) who wants to transact on the network must digitally sign the ```requestBody``` using the corresponding private key of this public key and send it in the transport layer header. In case of ```HTTP``` it is the ```Authorization``` header. <br><br/>The ```Authorization``` will be used to validate the signature of a BAP or BPP.<br/><br/>Furthermore, if an API call is being proxied or multicast by a Beckn Gateway, the BG must use it\\'s signing key to digitally sign the ```requestBody``` using the corresponding private key of this public key and send it in the ```X-Gateway-Authorization``` header.",
    )
    encryption_public_key: Optional[str] = Field(
        None,
        description='Encryption public key of the BAP subscriber. Any BPP must encrypt the ```requestBody.message``` value of the ```on_search``` API using this public key.',
    )
    status: Optional[Status2] = None
    created: Optional[datetime] = Field(
        None,
        description='Timestamp when a subscriber was added to the registry with status = INITIATED',
    )
    updated: Optional[datetime] = None
    expires: Optional[datetime] = Field(
        None,
        description='Expiry timestamp in UTC derived from the ```lease_time``` of the subscriber',
    )


class Support(BaseModel):
    type: Optional[Type5] = None
    ref_id: Optional[str] = None
    channels: Optional[Tags] = None


class TrackingData(BaseModel):
    __root__: Gps = Field(
        ...,
        description='Describes tracking data object during live tracking of an order',
    )


class AddOn(BaseModel):
    id: Optional[str] = Field(
        None,
        description='ID of the add-on. This follows the syntax {item.id}/add-on/{add-on unique id} for item specific add-on OR ',
    )
    descriptor: Optional[Descriptor] = None
    price: Optional[Price] = None


class Agent(Person, Contact):
    rateable: Optional[Rateable] = None


class Cancellation(BaseModel):
    type: Optional[Type] = None
    ref_id: Optional[str] = None
    policies: Optional[List[Policy]] = None
    time: Optional[datetime] = None
    cancelled_by: Optional[str] = None
    reasons: Optional[Option] = None
    selected_reason: Optional[SelectedReason] = None
    additional_description: Optional[Descriptor] = None


class Category(BaseModel):
    id: Optional[str] = Field(None, description='Unique id of the category')
    parent_category_id: Optional[IdModel] = None
    descriptor: Optional[Descriptor] = None
    time: Optional[Time] = None
    tags: Optional[Tags] = None


class FeedbackForm(BaseModel):
    __root__: List[FeedbackFormElement] = Field(
        ...,
        description='Describes a feedback form that a BPP can send to get feedback from the BAP',
    )


class Customer(BaseModel):
    person: Optional[Person] = None
    contact: Optional[Contact] = None


class Start(BaseModel):
    location: Optional[Location] = None
    time: Optional[Time] = None
    instructions: Optional[Descriptor] = None
    contact: Optional[Contact] = None
    person: Optional[Person] = None
    authorization: Optional[Authorization] = None


class End(BaseModel):
    location: Optional[Location] = None
    time: Optional[Time] = None
    instructions: Optional[Descriptor] = None
    contact: Optional[Contact] = None
    person: Optional[Person] = None
    authorization: Optional[Authorization] = None


class Fulfillment(BaseModel):
    id: Optional[str] = Field(
        None, description='Unique reference ID to the fulfillment of an order'
    )
    type: Optional[str] = Field(
        None, description='This describes the type of fulfillment'
    )
    provider_id: Optional[IdModel5] = None
    rating: Optional[ValueModel] = None
    state: Optional[State] = None
    tracking: Optional[bool] = Field(
        False, description='Indicates whether the fulfillment allows tracking'
    )
    customer: Optional[Customer] = None
    agent: Optional[Agent] = None
    person: Optional[Person] = None
    contact: Optional[Contact] = None
    vehicle: Optional[Vehicle] = None
    start: Optional[Start] = Field(
        None, description='Details on the start of fulfillment'
    )
    end: Optional[End] = Field(None, description='Details on the end of fulfillment')
    rateable: Optional[Rateable] = None
    tags: Optional[Tags] = None


class Operator(Person):
    experience: Optional[Experience] = None


class Order(BaseModel):
    id: Optional[str] = Field(None, description='Hash of order object without id')
    state: Optional[str] = None
    provider: Optional[Provider1] = None
    items: Optional[List[Item1]] = None
    add_ons: Optional[List[AddOn1]] = None
    offers: Optional[List[Offer1]] = None
    documents: Optional[List[Document]] = None
    billing: Optional[Billing] = None
    fulfillment: Optional[Fulfillment] = None
    quote: Optional[Quotation] = None
    payment: Optional[Payment] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


class Provider(BaseModel):
    id: Optional[str] = Field(None, description='Id of the provider')
    descriptor: Optional[Descriptor] = None
    category_id: Optional[str] = Field(None, description='Category Id of the provider')
    rating: Optional[ValueModel] = None
    time: Optional[Time] = None
    categories: Optional[List[Category]] = None
    fulfillments: Optional[List[Fulfillment]] = None
    payments: Optional[List[Payment]] = None
    locations: Optional[List[Location2]] = None
    offers: Optional[List[Offer]] = None
    items: Optional[List[Item]] = None
    exp: Optional[datetime] = Field(
        None, description='Time after which catalog has to be refreshed'
    )
    rateable: Optional[Rateable] = None
    tags: Optional[Tags] = None


class Rating(BaseModel):
    rating_category: Optional[str] = Field(
        None, description='Category of the object being rated'
    )
    id: Optional[str] = Field(None, description='Id of the object being rated')
    value: Optional[confloat(ge=0.0)] = Field(
        None, description='Rating value given to the object'
    )
    feedback_form: Optional[FeedbackForm] = None
    feedback_id: Optional[FeedbackId] = None


class Catalog(BaseModel):
    bpp_descriptor: Optional[Descriptor] = Field(None, alias='bpp/descriptor')
    bpp_categories: Optional[List[Category]] = Field(None, alias='bpp/categories')
    bpp_fulfillments: Optional[List[Fulfillment]] = Field(
        None, alias='bpp/fulfillments'
    )
    bpp_payments: Optional[List[Payment]] = Field(None, alias='bpp/payments')
    bpp_offers: Optional[List[Offer]] = Field(None, alias='bpp/offers')
    bpp_providers: Optional[List[Provider]] = Field(None, alias='bpp/providers')
    exp: Optional[datetime] = Field(
        None, description='Time after which catalog has to be refreshed'
    )


class Feedback(BaseModel):
    feedback_form: Optional[FeedbackForm] = None
    feedback_url: Optional[FeedbackUrl] = None


class Intent(BaseModel):
    descriptor: Optional[Descriptor] = None
    provider: Optional[Provider] = None
    fulfillment: Optional[Fulfillment] = None
    payment: Optional[Payment] = None
    category: Optional[Category] = None
    offer: Optional[Offer] = None
    item: Optional[Item] = None
    tags: Optional[Tags] = None
